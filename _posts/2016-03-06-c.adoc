= c#
:toc: macro
:hp-tags: c#

toc::[]

== classes/méthodes

=== différences c++,c#

* pas de section public, private dans les classes, chaque méthode est préfixée par public, private...
* Héritage public seulement entre les classes
* out, ref pour les paramètres

=== abstract, virtual override

Au niveau le pluys haut, on définit les méthodes soit abstraites (pas de def) soit virtual).

Une méthode redéfinie est override

[source,c#]
----
public virtual decimal CalculatePay()
        {
            return basepay;
        }
----

[source,c#]
----
public override decimal CalculatePay()
{
    return basepay + salesbonus;
}
----

=== out,ref

Utilisé pour les paramètres. 
Un paramètre out n'est pas initialisé.

Pour ref, il doit être initialisé par l'appelant

== types

=== differences c++/c#

* var <=> auto

* array +
[,] pour les array 2 dimensions, [][] pour les jagges array

* les struct sont des *value type*, les classes des *reference type* +
pas de new

=== boxing/unboxing

Boxing::
Encapsuler un type primitif dans un objet. Ce type de value type devient un reference type +
Exemple : pour mettre un int dans une liste d'objet.

[source,c#]
----
double e = 2.7; // boxing
object o = e; // box
double ee = (double)o; // unboxing
----

=== array

* simple

.tableau simle avec initialisation
[source,c#]
----
Shape[] shapes =
{
   new Square(5, "Square #1"),
   new Circle(3, "Circle #1"),
            new Rectangle( 4, 5, "Rectangle #1")
};
----

* multidimensionnel

[source,c#]
----
// Declare a two dimensional array
int[,] multiDimensionalArray1 = new int[2, 3];
----

* jagged

[source,c#]
----
int[][] jaggedArray = new int[6][];

// Set the values of the first array 
jaggedArray[0] = new int[4] { 1, 2, 3, 4 };
----

=== string

=== nullable (optional)


=== var

Déduction automatique de type
[source,c#]
----
var query = from item in source
            where item <= limit
            select item;
----

=== types anonymes

== delegate (lambda)

* delegate 

[source,c#]
----
// declaration de type function
public delegate void TestDelegate(string message); 

//exemple de lambda
new Thread(
   delegate() {
   	Console.WriteLine("ok");
   }
).Start();
----

* Func 

*Func* encapsule une fonction/delegate/lambda expression
[source,c#]
----
Func<int,int,int> = delegate(x,y) { return x+y; }
----

Pour une fonction qui retourne void, utiliser *Action*

* lambda expression

.Lambda expression
[source,c#]
----
Func<int,int,int> = ((x,y) => x+y)
----

== events

[source,c#]
----
// type delegate
public delegate void ChangedEventHandler(object sender, EventArgs e);

// donnee membre event
public event ChangedEventHandler Changed;

// ajout d'un listener, ListChanged est une methode par exemple
List.Changed += new ChangedEventHandler(ListChanged);

// trigger event -> comme un appel de fonction
Changed(this, e);

// detach
 List.Changed -= new ChangedEventHandler(ListChanged);
 
----

== propriétés

[source,c#]
----
class TimePeriod
{
    private double seconds;

    public double Hours
    {
        get { return seconds / 3600; }
        set { seconds = value * 3600; }
    }
}
----

On peut définir des propriétés dans une méthode abstraite, pour définir les getter/setter . Pour une propriété readonly mettre uniquement:

  get()


== 

