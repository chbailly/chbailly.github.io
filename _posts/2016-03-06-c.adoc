= c#
:toc: macro
:hp-tags: c#

toc::[]

== classes

=== diufférences c++,c#

* pas de section public, private dans les classes, chaque méthode est préfixée par public, private...
* Héritage public seulement entre les classes

=== abstract, virtual override

Au niveau le pluys haut, on définit les méthodes soit abstraites (pas de def) soit virtual).

Une méthode redéfinie est override

[source,c#]
----
public virtual decimal CalculatePay()
        {
            return basepay;
        }
----

[source,c#]
----
public override decimal CalculatePay()
{
    return basepay + salesbonus;
}
----
== types

=== differences c++/c#

array::
 [,] pour les array 2 dimensions, [][] pour les jagges array

=== array

* simple

.tableau simle avec initialisation
[source,c#]
----
Shape[] shapes =
{
   new Square(5, "Square #1"),
   new Circle(3, "Circle #1"),
            new Rectangle( 4, 5, "Rectangle #1")
};
----

* multidimensionnel

[source,c#]
----
// Declare a two dimensional array
int[,] multiDimensionalArray1 = new int[2, 3];
----

* jagged

[source,c#]
----
int[][] jaggedArray = new int[6][];

// Set the values of the first array 
jaggedArray[0] = new int[4] { 1, 2, 3, 4 };
----

=== string

=== nullable (optional)

=== types anonymes

== delegate (lambda)

* delegate 

[source,c#]
----
// declaration de type function
public delegate void TestDelegate(string message); 

//exemple de lambda
new Thread(
   delegate() {
   	Console.WriteLine("ok");
   }
).Start();
----

* Func 

*Func* encapsule une fonction/delegate/lambda expression
[source,c#]
----
Func<int,int,int> = delegate(x,y) { return x+y; }
----

Pour une fonction qui retourne void, utiliser *Action*

* lambda expression

.Lambda expression
[source,c#]
----
Func<int,int,int> = ((x,y) => x+y)
----

== events

[source,c#]
----
// type delegate
public delegate void ChangedEventHandler(object sender, EventArgs e);

// donnee membre event
public event ChangedEventHandler Changed;

// ajout d'un listener, ListChanged est une methode par exemple
List.Changed += new ChangedEventHandler(ListChanged);

// trigger event -> comme un appel de fonction
Changed(this, e);

// detach
 List.Changed -= new ChangedEventHandler(ListChanged);
 
----

== propriétés

[source,c#]
----
class TimePeriod
{
    private double seconds;

    public double Hours
    {
        get { return seconds / 3600; }
        set { seconds = value * 3600; }
    }
}
----

== 

