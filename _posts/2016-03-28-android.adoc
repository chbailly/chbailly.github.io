= android
:toc: macro
:toclevels: 5
:setanchors:


toc::[]

== intent

=== declaration dans manifest

Chaque activité déclarée peut avoir un intent associée pour qu'elle soit appelable (exportée) -> cf exemple (<<active_declare,declaration activité>>

=== startActivity(intent)

C'est l'intent qui contient l'information sur l'activité à démarrer. Elle peut être *explicit* ou *implicit*

=== explicit intent


* Invocation

[literal]
Intent(Context packageContext, Class<?> cls)


[source,java]
.Example (this est l'activity)
----
Intent intent = new Intent(this, SignInActivity.class);
startActivity(intent);
----

=== Implicit intent


* Invocation

[source,java]
----
// Create the text message with a string
Intent sendIntent = new Intent();
sendIntent.setAction(Intent.ACTION_SEND);
sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);
sendIntent.setType("text/plain");

// Verify that the intent will resolve to an activity
if (sendIntent.resolveActivity(getPackageManager()) != null) {
    startActivity(sendIntent);
}
----

* declaration dans manifest

Se fait dans le *manifest* , permet d'exporter l'intent pour qu'il soir appelable. On définit le profil de la méthode (attend un texte par exemple)

[source,xml]
.Intent in manifest
----
<activity android:name="ShareActivity">
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
    </intent-filter>
</activity>
----

=== Réception des données

.Recieve in onCreate
----
Intent intent = getIntent();
String message = intent.getStringExtra(MyActivity.EXTRA_MESSAGE);
----

== activity

=== declaration

Chaque activity doit être déclarée dnas un element <activity>. Il faut "exporter" (intent-filter) l'actibité principale pour qu'elle soit launchable.

[[active_declare]]
[source,xml]
----
<activity android:name="MainActivity">
    <!-- This activity is the main entry, should appear in app launcher -->
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
----

=== cycle de vie

==== différentes etat/boucles

image::http://developer.android.com/images/activity_lifecycle.png[link="http://developer.android.com/images/activity_lifecycle.png"]

====  onSaveInstanceState/onRestoreInstanceData

image::http://developer.android.com/images/fundamentals/restore_instance.png[link="http://developer.android.com/images/fundamentals/restore_instance.png"]

== fragments
=== Création UI

[source,java]
.Call inflate to create associated UI (in *example_fragment.xml*)
----
public static class ExampleFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        return inflater.inflate(R.layout.example_fragment, container, false);
    }
}
----

=== Ajout à un e activity

==== via layout de l'activity

[source,java]
.Ajout dans LinearLayout (par exemple)
----
<fragment android:name="com.example.news.ArticleListFragment"
       android:id="@+id/list"
       android:layout_weight="1"
       android:layout_width="0dp"
       android:layout_height="match_parent" />
----

==== Par la programmation (cf transactions)

=== transactions 

Gère l'ajout/remove/replace dans une transaction qui sera ajoutée à la backstrace

[source,java]
----
// Create new fragment and transaction
Fragment newFragment = new ExampleFragment();
FragmentTransaction transaction = getFragmentManager().beginTransaction();

// Replace whatever is in the fragment_container view with this fragment,
// and add the transaction to the back stack
transaction.replace(R.id.fragment_container, newFragment);
transaction.addToBackStack(null);

// Commit the transaction
transaction.commit();
----
